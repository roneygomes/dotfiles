#!/bin/bash

# Usage: worktree-switch <branch_name>
# Creates and switches to a worktree for the given branch in a bare-cloned project

set -e

BRANCH_INPUT=$1

if [ -z "$BRANCH_INPUT" ]; then
    echo "Usage: worktree-switch <branch_name>"
    echo ""
    echo "Examples:"
    echo "  worktree-switch my-feature          # Creates worktree for branch"
    echo "  worktree-switch feat/my-feature     # Handles branch prefixes"
    echo "  worktree-switch 123                 # Works with ticket numbers"
    exit 1
fi

# Find the project root (where .bare is located)
find_project_root() {
    local current_dir="$PWD"
    
    # Check if we're in a git worktree
    if git rev-parse --is-inside-work-tree &>/dev/null; then
        # Get the common git directory (points to .bare)
        local git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
        if [ -n "$git_common_dir" ]; then
            # Get the directory containing .bare
            local bare_dir=$(cd "$git_common_dir" && pwd)
            if [ "$(basename "$bare_dir")" = ".bare" ]; then
                # Return the parent directory
                dirname "$bare_dir"
                return 0
            fi
        fi
    fi
    
    # Fallback: walk up to find .bare directory
    while [ "$current_dir" != "/" ]; do
        if [ -d "$current_dir/.bare" ]; then
            echo "$current_dir"
            return 0
        fi
        current_dir=$(dirname "$current_dir")
    done
    
    return 1
}

PROJECT_ROOT=$(find_project_root)

if [ -z "$PROJECT_ROOT" ]; then
    echo "Error: Not in a bare-cloned project directory."
    echo "This script works with projects set up using setup-project."
    exit 1
fi

# Change to project root
cd "$PROJECT_ROOT"

# Function to find matching branch
find_branch() {
    local input=$1
    local branches
    
    # Get all remote branches
    branches=$(git --git-dir=.bare branch -r 2>&1 | sed 's/origin\///' | sed 's/^[[:space:]]*//' | grep -v '^HEAD' || true)
    
    # Try exact match first
    if echo "$branches" | grep -q "^${input}$" || false; then
        echo "$input"
        return 0
    fi
    
    # Try with common prefixes
    local prefixes=("feat/" "feature/" "fix/" "bugfix/" "hotfix/" "chore/" "docs/" "refactor/" "test/" "style/")
    
    for prefix in "${prefixes[@]}"; do
        if echo "$branches" | grep -q "^${prefix}${input}$" || false; then
            echo "${prefix}${input}"
            return 0
        fi
    done
    
    # Try partial match (case-insensitive)
    local matches=$(echo "$branches" | grep -i "$input" || true)
    local match_count=$(echo "$matches" | grep -v '^$' | wc -l | tr -d ' ' || echo "0")
    
    if [ "$match_count" -eq 1 ]; then
        echo "$matches"
        return 0
    elif [ "$match_count" -gt 1 ]; then
        echo "Error: Multiple branches match '$input':" >&2
        echo "$matches" | sed 's/^/  - /' >&2
        return 1
    fi
    
    # No match found - assume it's a new branch name
    echo "$input"
    return 2
}

# Find the branch
BRANCH_NAME=$(find_branch "$BRANCH_INPUT") || FIND_RESULT=$?
FIND_RESULT=${FIND_RESULT:-0}

if [ $FIND_RESULT -eq 1 ]; then
    # Multiple matches found, error already printed
    exit 1
fi

# Determine worktree directory name (use last part of branch for directory)
WORKTREE_DIR=$(basename "$BRANCH_NAME")

# Check if worktree directory already exists
if [ -d "$WORKTREE_DIR" ]; then
    echo "Worktree directory '$WORKTREE_DIR' already exists. Switching to it..."
    cd "$WORKTREE_DIR"
    echo "✅ Now in worktree: $WORKTREE_DIR"
    echo "   Branch: $(git branch --show-current)"
    echo "   Path: $(pwd)"
    # Start a new shell in the worktree
    exec $SHELL
fi

# Check if branch exists remotely
BRANCH_EXISTS=$(git --git-dir=.bare branch -r | grep -c "origin/${BRANCH_NAME}" || true)

if [ "$BRANCH_EXISTS" -gt 0 ]; then
    echo "Creating worktree for existing branch: $BRANCH_NAME"
    git worktree add "$WORKTREE_DIR" "origin/$BRANCH_NAME"
else
    echo "Branch '$BRANCH_NAME' not found remotely."
    read -p "Create new branch '$BRANCH_NAME'? (y/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Find the default/main branch to base off
        DEFAULT_BRANCH=$(git --git-dir=.bare symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@refs/remotes/origin/@@' || echo "main")
        
        # Check if default branch exists, otherwise try common alternatives
        if ! git --git-dir=.bare show-ref --verify --quiet "refs/remotes/origin/$DEFAULT_BRANCH"; then
            for branch in "main" "master" "devnet" "develop"; do
                if git --git-dir=.bare show-ref --verify --quiet "refs/remotes/origin/$branch"; then
                    DEFAULT_BRANCH=$branch
                    break
                fi
            done
        fi
        
        echo "Creating new branch '$BRANCH_NAME' based on '$DEFAULT_BRANCH'..."
        git worktree add -b "$BRANCH_NAME" "$WORKTREE_DIR" "origin/$DEFAULT_BRANCH"
    else
        echo "Cancelled."
        exit 1
    fi
fi

# Switch to the worktree directory
cd "$WORKTREE_DIR"

echo "✅ Switched to worktree: $WORKTREE_DIR"
echo "   Branch: $(git branch --show-current)"
echo "   Path: $(pwd)"

# Start a new shell in the worktree
exec $SHELL
