#!/bin/bash

# Usage: worktree-switch <branch_name>
# Creates and switches to a centralized worktree for the given branch

set -e

BRANCH_INPUT=$1
TREES_BASE_DIR="${PROJ_TREES_DIR:-$HOME/.proj/trees}"
TREES_BASE_DIR="${TREES_BASE_DIR/#\~/$HOME}"

if [ -z "$BRANCH_INPUT" ]; then
    echo "Usage: worktree-switch <branch_name>"
    echo ""
    echo "Examples:"
    echo "  worktree-switch my-feature"
    echo "  worktree-switch feat/my-feature"
    echo "  worktree-switch 123"
    exit 1
fi

find_project_root() {
    local project_root=""

    if git rev-parse --is-inside-work-tree &>/dev/null; then
        local git_common_dir
        git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
        if [ -n "$git_common_dir" ]; then
            local common_dir_abs
            common_dir_abs=$(cd "$git_common_dir" 2>/dev/null && pwd)
            case "$(basename "$common_dir_abs")" in
                .bare|.git)
                    project_root=$(dirname "$common_dir_abs")
                    ;;
            esac
        fi

        if [ -z "$project_root" ]; then
            local toplevel
            toplevel=$(git rev-parse --show-toplevel 2>/dev/null || true)
            if [ -n "$toplevel" ] && { [ -d "$toplevel/.git" ] || [ -d "$toplevel/.bare" ]; }; then
                project_root="$toplevel"
            fi
        fi
    fi

    if [ -z "$project_root" ]; then
        local current_dir="$PWD"
        while [ "$current_dir" != "/" ]; do
            if [ -d "$current_dir/.git" ] || [ -d "$current_dir/.bare" ]; then
                project_root="$current_dir"
                break
            fi
            current_dir=$(dirname "$current_dir")
        done
    fi

    [ -n "$project_root" ] && echo "$project_root"
}

is_legacy_bare_project() {
    local project_root=$1
    [ -d "$project_root/.bare" ]
}

git_project() {
    local project_root=$1
    shift

    if is_legacy_bare_project "$project_root"; then
        git --git-dir="$project_root/.bare" "$@"
    else
        git -C "$project_root" "$@"
    fi
}

tmux_session_name_for_tree() {
    local tree_name=$1
    local session_name
    session_name=$(echo "$tree_name" | sed 's/[^[:alnum:]_-]/-/g')
    [ -n "$session_name" ] || session_name="tree"
    echo "$session_name"
}

switch_to_tree() {
    local tree_path=$1
    local tree_name=$2

    if ! command -v tmux &> /dev/null; then
        cd "$tree_path"
        exec "$SHELL"
    fi

    local session_name
    session_name=$(tmux_session_name_for_tree "$tree_name")

    if tmux has-session -t "$session_name" 2>/dev/null; then
        if [ -n "${TMUX:-}" ]; then
            tmux switch-client -t "$session_name"
        else
            tmux attach-session -t "$session_name"
        fi
    else
        if [ -n "${TMUX:-}" ]; then
            tmux new-session -d -s "$session_name" -c "$tree_path"
            tmux switch-client -t "$session_name"
        else
            tmux new-session -s "$session_name" -c "$tree_path"
        fi
    fi
}

PROJECT_ROOT=$(find_project_root)

if [ -z "$PROJECT_ROOT" ]; then
    echo "Error: Not inside a git project or worktree."
    exit 1
fi

cd "$PROJECT_ROOT"
PROJECT_NAME=$(basename "$PROJECT_ROOT")
PROJECT_TREES_DIR="$TREES_BASE_DIR/$PROJECT_NAME"
mkdir -p "$PROJECT_TREES_DIR"

find_branch() {
    local input=$1
    local branches

    branches=$(git_project "$PROJECT_ROOT" branch -r 2>/dev/null | sed 's/origin\///' | sed 's/^[[:space:]]*//' | grep -v '^HEAD' || true)

    if echo "$branches" | grep -q "^${input}$" || false; then
        echo "$input"
        return 0
    fi

    local prefixes=("feat/" "feature/" "fix/" "bugfix/" "hotfix/" "chore/" "docs/" "refactor/" "test/" "style/")
    for prefix in "${prefixes[@]}"; do
        if echo "$branches" | grep -q "^${prefix}${input}$" || false; then
            echo "${prefix}${input}"
            return 0
        fi
    done

    local matches
    matches=$(echo "$branches" | grep -i "$input" || true)
    local match_count
    match_count=$(echo "$matches" | grep -v '^$' | wc -l | tr -d ' ' || echo "0")

    if [ "$match_count" -eq 1 ]; then
        echo "$matches"
        return 0
    elif [ "$match_count" -gt 1 ]; then
        echo "Error: Multiple branches match '$input':" >&2
        echo "$matches" | sed 's/^/  - /' >&2
        return 1
    fi

    echo "$input"
    return 2
}

BRANCH_NAME=$(find_branch "$BRANCH_INPUT") || FIND_RESULT=$?
FIND_RESULT=${FIND_RESULT:-0}

if [ "$FIND_RESULT" -eq 1 ]; then
    exit 1
fi

WORKTREE_DIR=$(basename "$BRANCH_NAME")
WORKTREE_PATH="$PROJECT_TREES_DIR/$WORKTREE_DIR"

if [ -d "$WORKTREE_PATH" ]; then
    echo "Worktree directory '$WORKTREE_DIR' already exists. Switching to it..."
    switch_to_tree "$WORKTREE_PATH" "$WORKTREE_DIR"
fi

if git_project "$PROJECT_ROOT" show-ref --verify --quiet "refs/remotes/origin/$BRANCH_NAME"; then
    echo "Creating worktree for existing branch: $BRANCH_NAME"
    git_project "$PROJECT_ROOT" worktree add "$WORKTREE_PATH" "origin/$BRANCH_NAME"
else
    echo "Branch '$BRANCH_NAME' not found remotely."
    read -p "Create new branch '$BRANCH_NAME'? (y/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        DEFAULT_BRANCH=$(git_project "$PROJECT_ROOT" symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@refs/remotes/origin/@@' || echo "main")

        if ! git_project "$PROJECT_ROOT" show-ref --verify --quiet "refs/remotes/origin/$DEFAULT_BRANCH"; then
            for branch in "main" "master" "devnet" "develop"; do
                if git_project "$PROJECT_ROOT" show-ref --verify --quiet "refs/remotes/origin/$branch"; then
                    DEFAULT_BRANCH=$branch
                    break
                fi
            done
        fi

        echo "Creating new branch '$BRANCH_NAME' based on '$DEFAULT_BRANCH'..."
        git_project "$PROJECT_ROOT" worktree add -b "$BRANCH_NAME" "$WORKTREE_PATH" "origin/$DEFAULT_BRANCH"
    else
        echo "Cancelled."
        exit 1
    fi
fi

switch_to_tree "$WORKTREE_PATH" "$WORKTREE_DIR"
