#!/bin/bash

# proj - A CLI tool for managing bare-cloned projects and worktrees

set -e

VERSION="1.0.0"

show_help() {
    cat << EOF
proj - Manage bare-cloned projects and worktrees

Usage:
  proj clone <git-url> [project-name]    Clone a repository as a bare repo
  proj task <worktree>                   Switch to or create a worktree
  proj list                              List worktrees with fzf fuzzy finder
  proj delete                            Delete a worktree with fzf selection
  proj --version                         Show version
  proj --help                            Show this help message

Examples:
  proj clone git@github.com:user/repo.git
  proj clone https://github.com/user/repo.git my-project
  proj task feat/new-feature
  proj task 123
  proj list    # Opens fzf to select and switch to a worktree
  proj delete  # Opens fzf to select and delete a worktree

Tab Completion:
  The 'proj task' command supports tab completion for existing worktrees.
  See ~/.zshrc for completion setup.
EOF
}

show_version() {
    echo "proj version $VERSION"
}

cmd_clone() {
    local git_url=$1
    local project_name=$2
    
    if [ -z "$git_url" ]; then
        echo "Error: Git URL is required"
        echo "Usage: proj clone <git-url> [project-name]"
        exit 1
    fi
    
    # Call setup-project
    if [ -n "$project_name" ]; then
        setup-project "$git_url" "$project_name"
    else
        setup-project "$git_url"
    fi
}

cmd_task() {
    local worktree=$1
    
    if [ -z "$worktree" ]; then
        echo "Error: Worktree name is required"
        echo "Usage: proj task <worktree>"
        exit 1
    fi
    
    # Call worktree-switch
    worktree-switch "$worktree"
}

cmd_list() {
    # Find the project root
    local project_root=""
    
    if git rev-parse --is-inside-work-tree &>/dev/null; then
        local git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
        if [ -n "$git_common_dir" ]; then
            local bare_dir=$(cd "$git_common_dir" 2>/dev/null && pwd)
            if [ "$(basename "$bare_dir")" = ".bare" ]; then
                project_root=$(dirname "$bare_dir")
            fi
        fi
    fi
    
    # Fallback: walk up to find .bare
    if [ -z "$project_root" ]; then
        local current_dir="$PWD"
        while [ "$current_dir" != "/" ]; do
            if [ -d "$current_dir/.bare" ]; then
                project_root="$current_dir"
                break
            fi
            current_dir=$(dirname "$current_dir")
        done
    fi
    
    if [ -z "$project_root" ]; then
        echo "Error: Not in a bare-cloned project directory."
        exit 1
    fi
    
    # Check if fzf is available
    if ! command -v fzf &> /dev/null; then
        echo "Worktrees in $(basename "$project_root"):"
        cd "$project_root"
        
        # Simple list without fzf
        for dir in */; do
            if [ -d "$dir" ] && [ "$(basename "$dir")" != ".bare" ]; then
                local worktree_name=$(basename "$dir")
                if [ -d "$dir/.git" ] || [ -f "$dir/.git" ]; then
                    local ref=$(cd "$dir" && git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD 2>/dev/null || echo "unknown")
                    echo "  - $worktree_name (ref: $ref)"
                fi
            fi
        done
        return
    fi
    
    # Build list of worktrees for fzf
    local worktree_list=""
    cd "$project_root"
    
    for dir in */; do
        if [ -d "$dir" ] && [ "$(basename "$dir")" != ".bare" ]; then
            local worktree_name=$(basename "$dir")
            if [ -d "$dir/.git" ] || [ -f "$dir/.git" ]; then
                local ref=$(cd "$dir" && git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD 2>/dev/null || echo "unknown")
                worktree_list="$worktree_list$worktree_name|$ref\n"
            fi
        fi
    done
    
    if [ -z "$worktree_list" ]; then
        echo "No worktrees found in $(basename "$project_root")"
        return
    fi
    
    # Use fzf to select a worktree
    local selected=$(echo -e "$worktree_list" | sed '/^$/d' | \
        awk -F'|' '{printf "%-30s %s\n", $1, "(ref: " $2 ")"}' | \
        fzf --height 40% --reverse --border \
            --header "Select worktree to switch to:" \
            --preview "echo {} | awk '{print \$1}' | xargs -I {} ls -la $project_root/{}" \
            --preview-window=right:50%:wrap)
    
    if [ -n "$selected" ]; then
        # Extract worktree name (first field)
        local worktree_name=$(echo "$selected" | awk '{print $1}')
        local worktree_path="$project_root/$worktree_name"
        
        if [ -d "$worktree_path" ]; then
            cd "$worktree_path"
            echo "✅ Switched to worktree: $worktree_name"
            echo "   Path: $worktree_path"
            # Start a new shell in the worktree directory
            exec $SHELL
        else
            echo "Error: Worktree directory not found: $worktree_path"
            exit 1
        fi
    fi
}

cmd_delete() {
    # Find the project root
    local project_root=""
    
    if git rev-parse --is-inside-work-tree &>/dev/null; then
        local git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
        if [ -n "$git_common_dir" ]; then
            local bare_dir=$(cd "$git_common_dir" 2>/dev/null && pwd)
            if [ "$(basename "$bare_dir")" = ".bare" ]; then
                project_root=$(dirname "$bare_dir")
            fi
        fi
    fi
    
    # Fallback: walk up to find .bare
    if [ -z "$project_root" ]; then
        local current_dir="$PWD"
        while [ "$current_dir" != "/" ]; do
            if [ -d "$current_dir/.bare" ]; then
                project_root="$current_dir"
                break
            fi
            current_dir=$(dirname "$current_dir")
        done
    fi
    
    if [ -z "$project_root" ]; then
        echo "Error: Not in a bare-cloned project directory."
        exit 1
    fi
    
    # Get current worktree to prevent self-deletion
    local current_worktree=""
    if git rev-parse --is-inside-work-tree &>/dev/null; then
        current_worktree=$(basename "$(git rev-parse --show-toplevel 2>/dev/null)")
    fi
    
    # Check if fzf is available
    if ! command -v fzf &> /dev/null; then
        echo "Error: fzf is required for 'proj delete'. Please install fzf."
        exit 1
    fi
    
    # Build list of worktrees for fzf
    local worktree_list=""
    cd "$project_root"
    
    for dir in */; do
        if [ -d "$dir" ] && [ "$(basename "$dir")" != ".bare" ]; then
            local worktree_name=$(basename "$dir")
            if [ -d "$dir/.git" ] || [ -f "$dir/.git" ]; then
                # Skip current worktree
                if [ "$worktree_name" = "$current_worktree" ]; then
                    continue
                fi
                local ref=$(cd "$dir" && git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD 2>/dev/null || echo "unknown")
                worktree_list="$worktree_list$worktree_name|$ref\n"
            fi
        fi
    done
    
    if [ -z "$worktree_list" ]; then
        echo "No deletable worktrees found in $(basename "$project_root")"
        echo "(Current worktree cannot be deleted)"
        return
    fi
    
    # Use fzf to select worktrees to delete (multi-select enabled)
    local selected=$(echo -e "$worktree_list" | sed '/^$/d' | \
        awk -F'|' '{printf "%-30s %s\n", $1, "(ref: " $2 ")"}' | \
        fzf --multi --height 40% --reverse --border \
            --header "Select worktree(s) to DELETE (Tab to multi-select, Enter to confirm):" \
            --preview "echo {} | awk '{print \$1}' | xargs -I {} sh -c 'echo \"Worktree: {}\"; echo \"\"; git --git-dir=$project_root/.bare worktree list | grep {}'" \
            --preview-window=right:50%:wrap)
    
    if [ -z "$selected" ]; then
        echo "No worktree selected. Cancelled."
        return
    fi
    
    # Process each selected worktree
    # Use process substitution instead of pipe to avoid subshell issues
    while IFS= read -r line; do
        local worktree_name=$(echo "$line" | awk '{print $1}')
        local worktree_path="$project_root/$worktree_name"
        
        if [ -d "$worktree_path" ]; then
            echo ""
            echo "About to delete worktree: $worktree_name"
            read -p "Are you sure? (y/N): " -n 1 -r
            echo
            
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                # Need to run git worktree remove from an existing worktree
                # Find any existing worktree to run the command from
                local run_from=""
                for dir in "$project_root"/*; do
                    if [ -d "$dir" ] && [ "$(basename "$dir")" != ".bare" ] && [ "$dir" != "$worktree_path" ]; then
                        if [ -f "$dir/.git" ] || [ -d "$dir/.git" ]; then
                            run_from="$dir"
                            break
                        fi
                    fi
                done
                
                local removed=false
                
                # Try to remove using git worktree remove from another worktree
                if [ -n "$run_from" ]; then
                    (
                        cd "$run_from" || exit 1
                        git worktree remove "$worktree_path" --force
                    )
                    local exit_code=$?
                    
                    if [ $exit_code -eq 0 ]; then
                        echo "✅ Removed worktree: $worktree_name"
                        removed=true
                    fi
                fi
                
                # Fallback: remove directory manually and prune
                if [ "$removed" = false ]; then
                    if rm -rf "$worktree_path"; then
                        echo "✅ Removed worktree directory: $worktree_name"
                        # Prune the worktree reference from git
                        if [ -n "$run_from" ]; then
                            (cd "$run_from" && git worktree prune)
                        fi
                    else
                        echo "❌ Failed to remove worktree: $worktree_name"
                    fi
                fi
            else
                echo "Skipped: $worktree_name"
            fi
        else
            echo "⚠️  Worktree directory not found: $worktree_path"
        fi
    done < <(echo "$selected")
    
    echo ""
    echo "Cleanup complete."
}

# Main command router
case "${1:-}" in
    clone)
        shift
        cmd_clone "$@"
        ;;
    task)
        shift
        cmd_task "$@"
        ;;
    list)
        shift
        cmd_list "$@"
        ;;
    delete)
        shift
        cmd_delete "$@"
        ;;
    --version|-v)
        show_version
        ;;
    --help|-h|"")
        show_help
        ;;
    *)
        echo "Error: Unknown command '$1'"
        echo ""
        show_help
        exit 1
        ;;
esac
